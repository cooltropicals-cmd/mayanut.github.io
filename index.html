<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>MayaNut</title>
<style>
  :root{
    --ink:#eaf2ff; --ink-dim:#c6d0ea;
    --panel:rgba(12,16,34,.45); --line:rgba(255,255,255,.12);
    --accent:#99b7ff; --accent2:#c79bff;
    --inputBG:rgba(255,255,255,.08); --inputLine:rgba(255,255,255,.22);
    --shadow:0 18px 40px rgba(0,0,0,.45);
    --galaxy1: rgba(156,124,255,.22); --galaxy2: rgba(85,180,255,.20); --galaxy3: rgba(255,170,220,.16);
    --danger:#ff4d4d;
  }

  html,body{height:100%}
  body{
    margin:0;color:var(--ink);
    font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, "Helvetica Neue", Arial, sans-serif;
    display:flex; flex-direction:column; min-height:100%;
    background:
      radial-gradient(1000px 600px at 15% -10%, rgba(115,94,225,.35), transparent 60%),
      radial-gradient(1100px 700px at 85% 0%, rgba(168,78,255,.28), transparent 65%),
      radial-gradient(900px 500px at 50% 120%, rgba(34,124,255,.22), transparent 60%),
      linear-gradient(180deg, #0a0f2c 0%, #12163f 40%, #1c1f54 100%);
    overflow-x:hidden;
  }

  /* Stars + twinkle */
  .stars,.stars2,.stars3{position:fixed; inset:0; pointer-events:none; background-repeat:repeat; animation:twinkle 6s ease-in-out infinite}
  .stars{opacity:.75;background-image:
      radial-gradient(2px 2px at 20% 30%, rgba(255,255,255,.9) 99%, transparent),
      radial-gradient(1.5px 1.5px at 70% 20%, rgba(255,255,255,.8) 99%, transparent),
      radial-gradient(1.8px 1.8px at 40% 80%, rgba(255,255,255,.85) 99%, transparent),
      radial-gradient(1.2px 1.2px at 85% 65%, rgba(255,255,255,.75) 99%, transparent)}
  .stars2{opacity:.6; animation-delay:1.2s;background-image:
      radial-gradient(1.5px 1.5px at 10% 70%, rgba(255,255,255,.8) 99%, transparent),
      radial-gradient(2px 2px at 55% 50%, rgba(255,255,255,.9) 99%, transparent),
      radial-gradient(1.3px 1.3px at 92% 40%, rgba(255,255,255,.7) 99%, transparent)}
  .stars3{opacity:.55; animation-delay:2.2s;background-image:
      radial-gradient(1.6px 1.6px at 32% 54%, rgba(255,255,255,.7) 99%, transparent),
      radial-gradient(1.2px 1.2px at 76% 78%, rgba(255,255,255,.65) 99%, transparent),
      radial-gradient(1.0px 1.0px at 15% 12%, rgba(255,255,255,.6) 99%, transparent)}
  @keyframes twinkle{0%,100%{opacity:.55;filter:brightness(1)}50%{opacity:.95;filter:brightness(1.25)}}

  /* Spinning galaxies */
  .galaxy{position:fixed; pointer-events:none; border-radius:50%; filter:blur(1px) saturate(120%) brightness(1.05); mix-blend-mode:screen; opacity:.35; animation:spin 140s linear infinite}
  .galaxy.g1{width:540px;height:540px;left:6%;top:10%;background:
      radial-gradient(closest-side, var(--galaxy2), transparent 70%),
      radial-gradient(closest-side, var(--galaxy1), transparent 40%)}
  .galaxy.g2{width:420px;height:420px;right:8%;top:18%;background:
      radial-gradient(closest-side, var(--galaxy3), transparent 70%),
      radial-gradient(closest-side, var(--galaxy2), transparent 40%);animation-duration:160s;animation-direction:reverse}
  .galaxy.g3{width:600px;height:600px;left:50%;bottom:-8%;transform:translateX(-50%);background:
      radial-gradient(closest-side, var(--galaxy1), transparent 70%),
      radial-gradient(closest-side, var(--galaxy3), transparent 40%);animation-duration:180s}
  @keyframes spin{from{transform:rotate(0deg)}to{transform:rotate(360deg)}}

  /* Top bar */
  .topbar{position:fixed;top:0;left:0;right:0;z-index:30;display:flex;align-items:center;justify-content:space-between;padding:10px 14px;background:var(--panel);border-bottom:1px solid var(--line);backdrop-filter:blur(10px) saturate(140%)}
  .brand{font-weight:800;letter-spacing:.2px;color:#fff;display:flex;align-items:center;gap:6px;user-select:none}
  .brand small{font-size:11px;opacity:.95;vertical-align:top}
  .brandInfo{position:absolute; top:42px; left:14px; font-size:12px; color:#dfe7ff; opacity:.9} /* counter under logo */

  .nav{display:flex;gap:18px}
  .nav a{color:var(--ink);text-decoration:none;font-weight:700;font-size:14px;padding:8px 12px;border-radius:10px;border:1px solid transparent}
  .nav a:hover{border-color:var(--line);background:rgba(255,255,255,.06)}

  /* Score badge */
  .score{position:fixed; top:58px; right:12px; z-index:31; background:rgba(8,12,30,.7);
    border:1px solid var(--line); border-radius:12px; padding:6px 10px; font-size:13px; box-shadow:var(--shadow)}

  /* Hero + chat */
  .stage{flex:1;display:flex;align-items:center;justify-content:center;padding-top:88px;padding-bottom:80px}
  .panel{width:min(900px,92vw);text-align:center}
  .title{font-weight:900;font-size:clamp(44px,6vw,68px);line-height:1.05;letter-spacing:.6px;color:#fff;text-shadow:0 8px 28px rgba(0,0,0,.35);margin:6px 0 14px}
  .title .glow{background:linear-gradient(90deg,var(--accent),var(--accent2));-webkit-background-clip:text;background-clip:text;color:transparent;filter:drop-shadow(0 6px 26px rgba(156,124,255,.25))}
  .title small{font-size:.35em;color:#fff;opacity:.95;vertical-align:super;margin-left:4px}

  .chatbar{display:flex;align-items:center;gap:10px;justify-content:center;margin:0 auto;width:min(760px,92vw)}
  .chatbar input{flex:1;height:42px;padding:10px 12px;font-size:15px;color:#e9eeff;background:var(--inputBG);border:1px solid var(--inputLine);border-radius:12px;outline:none;box-shadow:var(--shadow)}
  .chatbar input::placeholder{color:#bec8e6}
  .chatbar input:focus{border-color:rgba(160,188,255,.75);box-shadow:0 0 0 3px rgba(153,183,255,.25)}
  .log{width:min(760px,92vw);margin:12px auto 0;background:rgba(8,12,30,.6);border:1px solid var(--line);border-radius:14px;padding:12px;box-shadow:var(--shadow);max-height:42vh;overflow:auto}
  .msg{text-align:left;margin:6px 0;color:#eaf2ff}
  .msg strong{color:#cfe1ff}

  /* Sections */
  .section{width:min(980px,94vw);margin:24px auto 0;background:rgba(8,12,30,.55);border:1px solid var(--line);border-radius:16px;padding:18px;backdrop-filter:blur(4px);box-shadow:var(--shadow)}
  .section h3{margin:0 0 8px;color:#fff}
  .section p{margin:8px 0 0;color:var(--ink-dim)}

  /* Footer */
  footer{width:100%;color:#c9d3ef;border-top:1px solid var(--line);background:rgba(10,14,34,.55);backdrop-filter:blur(6px);text-align:center;font-size:13px;padding:12px 8px}

  /* Ball layer + Game Over overlay */
  #ballLayer{position:fixed;inset:0;z-index:9999;pointer-events:none}
  #gameOver{
    position:fixed; inset:0; z-index:10000; display:none; align-items:center; justify-content:center;
    background:rgba(0,0,0,.45); backdrop-filter: blur(2px); color:#fff; font-size:42px; font-weight:800;
    text-shadow:0 8px 24px rgba(0,0,0,.65)
  }

  @media (max-width:720px){.nav a{padding:6px 10px}}
</style>
</head>
<body>

  <!-- Stars & Galaxies -->
  <div class="stars"></div><div class="stars2"></div><div class="stars3"></div>
  <div class="galaxy g1"></div><div class="galaxy g2"></div><div class="galaxy g3"></div>

  <!-- Top bar -->
  <header class="topbar" role="banner">
    <div class="brand">MayaNut<small>™</small></div>
    <div class="brandInfo">Balls: <b id="ballCount">1</b>/19</div>
    <nav class="nav" aria-label="Primary">
      <a href="#home" id="navHome">MayaNut</a>
      <a href="#buy"  id="navBuy">Buy</a>
      <a href="#about" id="navAbout">About</a>
    </nav>
  </header>

  <!-- Score -->
  <div id="scoreHUD" class="score">Score: <b id="score">0</b></div>

  <!-- Hero + Chat -->
  <main id="home" class="stage">
    <div class="panel">
      <h1 id="heroTitle" class="title">
        <span class="glow">MayaNut</span><small>™</small>
      </h1>
      <div class="chatbar" role="search">
        <input id="chatInput" placeholder="Type What You Want" aria-label="Type what you want and press Enter" />
      </div>
      <div class="log" id="chatLog" aria-live="polite" aria-label="Conversation"></div>
    </div>
  </main>

  <!-- Buy -->
  <section id="buy" class="section" aria-labelledby="buyTitle">
    <h3 id="buyTitle">Buy</h3>
    <p>Search Through Our Wonderful Products — real items coming soon. For now, try typing what you’d like above.</p>
    <ul>
      <li>MayaNut Flour — placeholder</li>
      <li>MayaNut Drink — placeholder</li>
      <li>MayaNut Snacks — placeholder</li>
    </ul>
  </section>

  <!-- About -->
  <section id="about" class="section" aria-labelledby="aboutTitle">
    <h3 id="aboutTitle">About</h3>
    <p><strong>MayaNut</strong> is a South Florida company promoting the cultivation and appreciation of
      <em>Brosimum alicastrum</em>—the Maya Nut (Breadnut). We champion sustainable agroforestry and regenerative
      farming that restores soils, supports biodiversity, and produces resilient, nutritious foods.</p>
    <p>The roasted seed makes a rich, chocolatey, naturally caffeine-free beverage, and the flour is naturally
      gluten-free—great for pancakes, cookies, breads, and energy bars. With a smooth, nutty flavor, it pairs
      beautifully with cinnamon, vanilla, cacao, and tropical fruits.</p>
  </section>

  <!-- Footer -->
  <footer>© 2025 MayaNut LLC. All rights reserved.</footer>

  <!-- Ball overlay + Game Over -->
  <canvas id="ballLayer"></canvas>
  <div id="gameOver">Game Over</div>

<script>
  /* ===== Minimal chat behavior ===== */
  const input = document.getElementById('chatInput');
  const logBox = document.getElementById('chatLog');

  function say(role, text){
    const el = document.createElement('div');
    el.className = 'msg';
    el.innerHTML = `<strong>${role}:</strong> ${text}`;
    logBox.appendChild(el);
    logBox.scrollTop = logBox.scrollHeight;
  }

  function handleMessage(v){
    const t = (v||'').trim();
    if(!t) return;
    say('You', t);

    const low = t.toLowerCase();
    const domainTriggers = [
      "domain for sale","is this domain for sale","sell this domain","sell the domain",
      "buy this domain","buy the domain","is the domain for sale","are you selling the domain",
      "is mayanut.com for sale","for sale domain","purchase this domain","can i buy this domain"
    ];
    if (domainTriggers.some(k=>low.includes(k))) { say('MayaNut','mayanut.com is Not for Sale'); return; }
    if (low.includes('buy') || low.includes('product') || low.includes('shop')) {
      say('MayaNut','Head to the Buy section below for our upcoming products. (Placeholders for now.)');
      document.getElementById('buy').scrollIntoView({behavior:'smooth'}); return;
    }
    if (low.includes('about') || low.includes('company')) {
      say('MayaNut','We’re a South Florida company promoting the Maya Nut tree. Scroll to the About section for details.');
      document.getElementById('about').scrollIntoView({behavior:'smooth'}); return;
    }
    say('MayaNut', "Tell me what you want and I’ll point you in the right direction.");
  }

  input.addEventListener('keydown', (e)=>{
    if(e.key === 'Enter'){ handleMessage(input.value); input.value = ''; }
  });

  document.getElementById('navHome').addEventListener('click', (e)=>{ e.preventDefault(); document.getElementById('home').scrollIntoView({behavior:'smooth'}); input.focus(); });
  document.getElementById('navBuy').addEventListener('click',  (e)=>{ e.preventDefault(); document.getElementById('buy').scrollIntoView({behavior:'smooth'}); });
  document.getElementById('navAbout').addEventListener('click',(e)=>{ e.preventDefault(); document.getElementById('about').scrollIntoView({behavior:'smooth'}); });

  /* ===== Game engine with spatial hashing & new rules ===== */
  (function(){
    const scoreEl = document.getElementById('score');
    const ballCountEl = document.getElementById('ballCount');
    const gameOverEl = document.getElementById('gameOver');
    let score = 0; const addScore = d => { score += d; scoreEl.textContent = score; };

    const MAX_BALLS = 19;
    const canvas = document.getElementById('ballLayer');
    const ctx = canvas.getContext('2d');

    function resize(){
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      const cssW = window.innerWidth, cssH = window.innerHeight;
      canvas.style.width = cssW + 'px'; canvas.style.height = cssH + 'px';
      canvas.width = Math.round(cssW * dpr); canvas.height = Math.round(cssH * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }
    resize(); window.addEventListener('resize', resize);

    // Colliders
    const heroTitle = document.getElementById('heroTitle');
    const chatInput = document.getElementById('chatInput');
    const chatLog  = document.getElementById('chatLog');
    const buySec   = document.getElementById('buy');
    const aboutSec = document.getElementById('about');
    const topbar   = document.querySelector('.topbar');

    function getRects(){
      const list = [heroTitle, chatInput, chatLog, buySec, aboutSec, topbar];
      const rects = [];
      for (const el of list){
        if(!el) continue;
        const r = el.getBoundingClientRect();
        if (r.bottom >= -50 && r.top <= window.innerHeight + 50) {
          rects.push({x:r.left, y:r.top, w:r.width, h:r.height});
        }
      }
      return rects;
    }

    /* ==== Ball model ==== */
    // types: 'original' | 'small' | 'spawner' | 'killer'
    function tierToRadius(tier){ const t = Math.max(1, Math.min(15, tier|0)); return 8 + (4 * (t - 1) / 14); }

    function makeBall(opts={}){
      const {
        x=window.innerWidth*0.6, y=window.innerHeight*0.3,
        r=10, vx=3.2, vy=2.6, type='small', sizeTier=null, hasFast=false
      } = opts;
      return {
        x,y,r,vx,vy, type, sizeTier, hasFast,
        squashTimer:0, squashAxis:'y',
        jellyTimer:0, jellyPhase:0,
        balloonTimer:0, balloonAxis:'y',
        _dead:false
      };
    }

    const balls = [ makeBall({ type:'original', vx:1.1, vy:0.9, r:tierToRadius(7), sizeTier:7, hasFast:false }) ];
    updateBallCount();

    /* ==== Spatial Hash (reduces O(n^2)) ==== */
    const CELL = 48; // px
    function buildGrid(){
      const grid = new Map();
      for (let i=0;i<balls.length;i++){
        const b = balls[i]; if (b._dead) continue;
        const minx = Math.floor((b.x - b.r)/CELL), maxx = Math.floor((b.x + b.r)/CELL);
        const miny = Math.floor((b.y - b.r)/CELL), maxy = Math.floor((b.y + b.r)/CELL);
        for(let gx=minx; gx<=maxx; gx++){
          for(let gy=miny; gy<=maxy; gy++){
            const key = gx+','+gy;
            if(!grid.has(key)) grid.set(key, []);
            grid.get(key).push(i);
          }
        }
      }
      return grid;
    }
    function nearbyPairs(grid){
      const seen = new Set();
      const pairs = [];
      for (const ids of grid.values()){
        for (let a=0;a<ids.length;a++){
          for (let b=a+1;b<ids.length;b++){
            const i=ids[a], j=ids[b];
            const key = i<j ? (i+'-'+j) : (j+'-'+i);
            if (seen.has(key)) continue;
            seen.add(key); pairs.push([i,j]);
          }
        }
      }
      return pairs;
    }

    /* ==== Physics & collisions ==== */
    function bounceWall(b, W, H){
      if (b.x - b.r < 0){ b.x = b.r; b.vx = Math.abs(b.vx); b.squashTimer=8; b.squashAxis='x'; }
      if (b.x + b.r > W){ b.x = W - b.r; b.vx = -Math.abs(b.vx); b.squashTimer=8; b.squashAxis='x'; }
      if (b.y - b.r < 0){ b.y = b.r; b.vy = Math.abs(b.vy); b.squashTimer=8; b.squashAxis='y'; }
      if (b.y + b.r > H){ b.y = H - b.r; b.vy = -Math.abs(b.vy); b.squashTimer=8; b.squashAxis='y'; }
    }

    function collideWithRect(b, R){
      const nx = Math.max(R.x, Math.min(b.x, R.x + R.w));
      const ny = Math.max(R.y, Math.min(b.y, R.y + R.h));
      const dx = b.x - nx, dy = b.y - ny;
      if (dx*dx + dy*dy > b.r*b.r) return false;

      const cx = R.x + R.w/2, cy = R.y + R.h/2;
      const overlapX = (R.w/2 + b.r) - Math.abs(b.x - cx);
      const overlapY = (R.h/2 + b.r) - Math.abs(b.y - cy);

      if (overlapX < overlapY){
        b.vx *= -1; b.x += (b.vx>0?1:-1)*Math.max(1,overlapX*0.6); b.squashTimer=8; b.squashAxis='x';
      } else {
        b.vy *= -1; b.y += (b.vy>0?1:-1)*Math.max(1,overlapY*0.6); b.squashTimer=8; b.squashAxis='y';
      }

      // water balloon bend for big merged (we’ll piggyback: spawners that grew large can bend)
      if (b.type==='spawner' && b.r>=13 && b.balloonTimer===0){
        b.balloonTimer = 20;
        b.balloonAxis = (overlapX < overlapY) ? 'x' : 'y';
      }
      return true;
    }

    function accelerateOriginal(b){
      const speed = Math.hypot(b.vx, b.vy);
      const cap = (b.hasFast ? 9 : 4);
      const accel = 0.002;
      const ns = Math.min(cap, speed * (1 + accel));
      if (ns>0 && speed>0){ const f = ns/speed; b.vx*=f; b.vy*=f; }
    }

    function handleBallBall(i,j){
      const a=balls[i], b=balls[j];
      if (a._dead || b._dead) return;

      const dx = b.x - a.x, dy = b.y - a.y;
      const dist = Math.hypot(dx,dy);
      if (dist > a.r + b.r) return;

      // If any is killer -> delete the other (non-red). Killers ignore each other.
      if (a.type==='killer' && b.type!=='killer'){ b._dead = true; return; }
      if (b.type==='killer' && a.type!=='killer'){ a._dead = true; return; }
      if (a.type==='killer' && b.type==='killer'){ return; }

      // Spawner + Spawner -> Red Swarm (transform field into up to 19 red killers total)
      if ( (a.type==='spawner' || a.type==='original') && (b.type==='spawner' || b.type==='original') ){
        triggerRedSwarm( (a.x+b.x)/2, (a.y+b.y)/2 );
        return;
      }

      // Small + Small -> merge into Spawner
      if (a.type==='small' && b.type==='small'){
        mergeIntoSpawner(i,j);
        return;
      }

      // Otherwise, simple elastic-ish bounce
      const nx = dx / (dist||1), ny = dy / (dist||1);
      const p = 2 * (a.vx*nx + a.vy*ny - b.vx*nx - b.vy*ny) / 2;
      a.vx -= p*nx; a.vy -= p*ny;
      b.vx += p*nx; b.vy += p*ny;
      a.squashTimer = b.squashTimer = 8;
      a.squashAxis = Math.abs(nx)>Math.abs(ny)?'x':'y';
      b.squashAxis = a.squashAxis;
    }

    function mergeIntoSpawner(i,j){
      const a=balls[i], b=balls[j];
      // New spawner at mass-weighted midpoint (same mass so average), average velocity
      const nx = (a.x + b.x)/2, ny = (a.y + b.y)/2;
      const nvx = (a.vx + b.vx)/2, nvy = (a.vy + b.vy)/2;
      const nr = Math.sqrt(a.r*a.r + b.r*b.r); // area-additive radius
      a._dead = true; b._dead = true;
      if (balls.length - (a._dead?1:0) - (b._dead?1:0) >= MAX_BALLS) return; // respect cap

      balls.push(makeBall({
        x:nx, y:ny, vx:nvx, vy:nvy, r:Math.max(9, nr), type:'spawner'
      }));
      const sp = balls[balls.length-1];
      sp.jellyTimer = 16; sp.jellyPhase = 0;
    }

    function triggerRedSwarm(cx,cy){
      // Remove colliding spawners by marking everyone non-killer as dead first? No.
      // We’ll keep existing balls and spawn red killers up to the cap (19 total).
      // This keeps gameplay interesting and respects the global cap.
      // If you prefer to ALWAYS have exactly 19 reds only, let me know and I’ll switch it.

      // Count current balls; remove the two colliders handled by caller via dead flags if needed.
      // Here we just spawn killers up to fill to MAX_BALLS.
      let current = balls.filter(b=>!b._dead).length;
      const toSpawn = Math.max(0, MAX_BALLS - current);
      if (toSpawn === 0) return;

      const radius = 7.5;
      for (let i=0;i<toSpawn;i++){
        const ang = Math.random()*Math.PI*2;
        const spd = 2.5 + Math.random()*2.5;
        balls.push(makeBall({
          x: cx + Math.cos(ang)*(10+i*0.2),
          y: cy + Math.sin(ang)*(10+i*0.2),
          r: radius, vx: Math.cos(ang)*spd, vy: Math.sin(ang)*spd,
          type:'killer'
        }));
      }
    }

    /* ==== Drawing ==== */
    function drawBall(b){
      // squash/stretch on wall/UI
      let sx=1, sy=1;
      if (b.squashTimer>0){
        const t = b.squashTimer/8;
        const amt = 0.35 * Math.sin(t * Math.PI);
        if (b.squashAxis==='x'){ sx=1+amt; sy=1-amt; } else { sy=1+amt; sx=1-amt; }
      }
      // jelly merge wobble
      if (b.jellyTimer>0){ const wob = 0.15*Math.sin((b.jellyPhase+=0.35)); sx*=1+wob; sy*=1-wob; }
      // balloon bend
      if (b.balloonTimer>0){
        const t = b.balloonTimer/20, bow=0.45*Math.sin((1-t)*Math.PI);
        if (b.balloonAxis==='x'){ sx*=1+bow; sy*=1-bow*0.6; } else { sy*=1+bow; sx*=1-bow*0.6; }
      }

      ctx.save();
      ctx.translate(b.x, b.y);
      ctx.scale(sx, sy);

      // glow
      ctx.beginPath(); ctx.arc(0, 0, b.r+3, 0, Math.PI*2);
      ctx.fillStyle = (b.type==='killer') ? 'rgba(255,77,77,.35)' : 'rgba(255,255,255,.40)';
      ctx.fill();

      // core
      ctx.beginPath(); ctx.arc(0, 0, b.r, 0, Math.PI*2);
      ctx.fillStyle = (b.type==='killer') ? '#ff4d4d' : '#ffffff';
      ctx.fill();

      // rings
      if (b.type==='original' || b.type==='spawner'){
        ctx.lineWidth=2; ctx.strokeStyle = (b.type==='spawner') ? 'rgba(255,220,130,.85)' : 'rgba(153,183,255,.7)';
        ctx.beginPath(); ctx.arc(0,0,b.r+5,0,Math.PI*2); ctx.stroke();
      }

      ctx.restore();
    }

    /* ==== Loop ==== */
    function updateBallCount(){ ballCountEl.textContent = String(balls.filter(b=>!b._dead).length); }
    function checkGameOver(){
      const anyWhite = balls.some(b=>!b._dead && b.type!=='killer');
      if (!anyWhite){
        gameOverEl.style.display='flex';
        setTimeout(()=>location.reload(), 1800);
      }
    }

    function step(){
      const W = window.innerWidth, H = window.innerHeight;
      const rects = getRects();

      // Move & walls/UI
      for (const b of balls){
        if (b._dead) continue;
        b.x += b.vx; b.y += b.vy;
        if (b.type==='original'){ // gradual accel
          const speed = Math.hypot(b.vx,b.vy);
          const cap = (b.hasFast?9:4);
          const accel = 0.002;
          const ns = Math.min(cap, speed*(1+accel));
          if (ns>0 && speed>0){ const f=ns/speed; b.vx*=f; b.vy*=f; }
        }
        bounceWall(b, W, H);
        for (const R of rects) collideWithRect(b, R);
        if (b.squashTimer>0) b.squashTimer--;
        if (b.jellyTimer>0)  b.jellyTimer--;
        if (b.balloonTimer>0) b.balloonTimer--;
      }

      // Ball-ball collisions using spatial hash
      const grid = buildGrid();
      const pairs = nearbyPairs(grid);
      for (const [i,j] of pairs){ handleBallBall(i,j); }

      // Cleanup
      for (let k=balls.length-1;k>=0;k--) if (balls[k]._dead) balls.splice(k,1);

      // Draw
      ctx.clearRect(0,0,canvas.width,canvas.height);
      for (const b of balls) drawBall(b);

      updateBallCount();
      checkGameOver();
      requestAnimationFrame(step);
    }
    requestAnimationFrame(step);

    /* ==== Input / scoring / spawning ==== */
    function hitBallAt(x,y,b){ const dx=b.x-x, dy=b.y-y; return Math.hypot(dx,dy) <= b.r + 5; }

    document.addEventListener('click', (e)=>{
      if (e.target.closest('input, textarea, [contenteditable="true"]')) return; // no score change

      const x = e.clientX, y = e.clientY;
      let handled = false;

      // Prioritize clicking white balls (original/spawner/small)
      for (let idx=0; idx<balls.length; idx++){
        const b = balls[idx]; if (b._dead || b.type==='killer') continue;
        if (hitBallAt(x,y,b)){
          addScore(+1);
          handled = true;

          // push away
          const dx = b.x - x, dy = b.y - y, len=Math.max(1,Math.hypot(dx,dy));
          let pushX=(dx/len)*4.8, pushY=(dy/len)*4.8;
          const cap = (b.type==='original' && b.hasFast) ? 9 : 4;
          const sp=Math.hypot(pushX,pushY), f=Math.min(cap,sp)/(sp||1);
          b.vx = pushX*f; b.vy = pushY*f;

          // Original leveling: sizeTier up to 15
          if (b.type==='original'){
            if (b.sizeTier<15){ b.sizeTier++; b.r = tierToRadius(b.sizeTier); }
            b._clicks = (b._clicks||0)+1;
            if (b._clicks>=15){ b.hasFast=true; const curS=Math.hypot(b.vx,b.vy); if (curS<7){ const F=7/(curS||1); b.vx*=F; b.vy*=F; } }
          }

          // Spawner or Original can spawn a mini (respect cap)
          if ((b.type==='spawner' || b.type==='original') && balls.length < MAX_BALLS){
            const ang = Math.random()*Math.PI*2, spd = 1.6 + Math.random()*1.6;
            balls.push(makeBall({
              x: b.x + Math.cos(ang)*(b.r+6),
              y: b.y + Math.sin(ang)*(b.r+6),
              r: Math.max(5, Math.round(b.r * 0.6)),
              vx: Math.cos(ang)*spd, vy: Math.sin(ang)*spd, type:'small'
            }));
          }

          break;
        }
      }

      if (!handled){
        // Maybe clicked a killer (no points given), else miss
        const hitKiller = balls.some(b=>!b._dead && b.type==='killer' && hitBallAt(x,y,b));
        if (!hitKiller) addScore(-1); // miss
      }
    });
  })();
</script>
</body>
</html>
