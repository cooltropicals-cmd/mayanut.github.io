<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>MayaNut Biology Game</title>
  <style>
    body {
      margin: 0;
      background: radial-gradient(circle at top, #1e3c72, #2a5298);
      color: #fff;
      font-family: sans-serif;
      overflow: hidden;
    }
    #topbar {
      position: fixed;
      top: 0; left: 0; right: 0;
      background: rgba(0,0,0,0.4);
      padding: 10px;
      display: flex;
      justify-content: space-between;
      z-index: 10;
    }
    #gameCanvas {
      display: block;
    }
    #chat {
      position: fixed;
      bottom: 0; left: 0; right: 0;
      padding: 10px;
      background: rgba(0,0,0,0.4);
      display: flex;
    }
    #chat input {
      flex: 1;
      padding: 8px;
      font-size: 16px;
    }
  </style>
</head>
<body>
  <div id="topbar">
    <div>MayaNutâ„¢</div>
    <div>Score: <span id="score">0</span></div>
  </div>
  <canvas id="gameCanvas"></canvas>
  <div id="chat">
    <input id="chatInput" placeholder="Type commands like /spawn 20 gold...">
  </div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    let W = window.innerWidth, H = window.innerHeight;
    canvas.width = W; canvas.height = H;

    window.addEventListener("resize", () => {
      W = window.innerWidth; H = window.innerHeight;
      canvas.width = W; canvas.height = H;
    });

    // Colors and Stages
    const colors = ["white","grey","blue","black","gold","doctor-green","red","lightgrey"];
    const stages = ["little","medium","big"];
    let balls = [];
    let lines = [];
    let score = 0;
    const scoreEl = document.getElementById("score");
    const maxBalls = 300;

    // Ball constructor
    function makeBall(x,y,color,stage="little"){
      return {
        x,y,
        vx:(Math.random()-0.5)*2,
        vy:(Math.random()-0.5)*2,
        r:stage==="little"?6:stage==="medium"?10:14,
        color,
        stage,
        chainId:null,
        supercell:false,
        dead:false
      };
    }

    // Spawn helper
    function spawnBalls(n,color){
      let added = 0;
      for(let i=0;i<n;i++){
        if(balls.length >= maxBalls) break;
        balls.push(makeBall(Math.random()*W, Math.random()*H, color));
        added++;
      }
      return added;
    }

    // Stage promotion
    function promote(ball){
      if(ball.stage==="little"){ ball.stage="medium"; ball.r=10; }
      else if(ball.stage==="medium"){ ball.stage="big"; ball.r=14; }
    }

    // Stage demotion
    function demote(ball){
      if(ball.stage==="big"){ ball.stage="medium"; ball.r=10; }
      else if(ball.stage==="medium"){ ball.stage="little"; ball.r=6; }
    }

    // Supercell creation
    function tryCreateSupercell(chain){
      if(chain.length>=5 && chain.length<=8){
        let cx=0, cy=0;
        chain.forEach(id => { cx+=balls[id].x; cy+=balls[id].y; balls[id].dead=true; });
        cx/=chain.length; cy/=chain.length;
        balls.push({x:cx,y:cy,vx:0,vy:0,r:40,color:"gold",supercell:true,dead:false});
      }
    }

    // Chat commands
    const chatInput=document.getElementById("chatInput");
    chatInput.addEventListener("keydown",e=>{
      if(e.key==="Enter"){
        const text=chatInput.value.trim();
        chatInput.value="";
        if(text.startsWith("/")){
          const parts=text.slice(1).split(" ");
          const cmd=parts[0];
          if(cmd==="spawn"){
            const n=parseInt(parts[1])||1;
            const color=parts[2]||"white";
            if(colors.includes(color)){
              const added=spawnBalls(n,color);
              console.log(`Spawned ${added} ${color} balls`);
            }
          }
        }
      }
    });

    // Click scoring
    canvas.addEventListener("click",e=>{
      const mx=e.clientX,my=e.clientY;
      let hit=false;
      for(const b of balls){
        if(!b.dead){
          const d=Math.hypot(b.x-mx,b.y-my);
          if(d<b.r){
            hit=true; b.dead=true; score+=1;
          }
        }
      }
      if(!hit) score-=1;
      scoreEl.textContent=score;
    });

    // Main loop
    function update(){
      // Physics
      for(const b of balls){
        if(b.dead) continue;
        b.x+=b.vx; b.y+=b.vy;
        if(b.x<b.r||b.x>W-b.r) b.vx*=-1;
        if(b.y<b.r||b.y>H-b.r) b.vy*=-1;
      }

      // Gold line connections
      lines=[];
      let chains={};
      for(let i=0;i<balls.length;i++){
        const a=balls[i];
        if(a.dead||a.color!=="gold"||a.supercell) continue;
        for(let j=i+1;j<balls.length;j++){
          const b=balls[j];
          if(b.dead||b.color!=="gold"||b.supercell) continue;
          const d=Math.hypot(a.x-b.x,a.y-b.y);
          if(d<100){
            lines.push([a,b]);
            if(a.chainId==null && b.chainId==null){
              const id=Math.random();
              a.chainId=b.chainId=id;
              chains[id]=[i,j];
            } else if(a.chainId!=null && b.chainId==null){
              b.chainId=a.chainId; chains[a.chainId].push(j);
            } else if(a.chainId==null && b.chainId!=null){
              a.chainId=b.chainId; chains[b.chainId].push(i);
            } else if(a.chainId===b.chainId){
              chains[a.chainId].push(j);
            }
          }
        }
      }

      // Check for supercell formation
      for(const id in chains){
        tryCreateSupercell(chains[id]);
      }

      // Red hits: break supercells & gold -> lightgrey
      for(const r of balls.filter(b=>b.color==="red"&&!b.dead)){
        for(const g of balls.filter(b=>b.color==="gold"&&!b.dead)){
          const d=Math.hypot(r.x-g.x,r.y-g.y);
          if(d<r.r+g.r){
            g.color="lightgrey"; g.supercell=false;
          }
        }
        for(const s of balls.filter(b=>b.supercell&&!b.dead)){
          const d=Math.hypot(r.x-s.x,r.y-s.y);
          if(d<r.r+s.r){
            s.dead=true; // break apart supercell
          }
        }
      }

      // Lightgrey merges -> gold
      const light = balls.filter(b=>b.color==="lightgrey"&&!b.dead);
      for(let i=0;i<light.length;i++){
        for(let j=i+1;j<light.length;j++){
          const a=light[i], b=light[j];
          const d=Math.hypot(a.x-b.x,a.y-b.y);
          if(d<a.r+b.r){
            a.dead=true; b.dead=true;
            balls.push(makeBall(a.x,a.y,"gold","little"));
          }
        }
      }

      // Promote on collisions
      for(let i=0;i<balls.length;i++){
        for(let j=i+1;j<balls.length;j++){
          const a=balls[i], b=balls[j];
          if(a.dead||b.dead) continue;
          const d=Math.hypot(a.x-b.x,a.y-b.y);
          if(d<a.r+b.r && a.color===b.color && a.stage===b.stage && a.stage!=="big"){
            promote(a); promote(b);
          }
        }
      }

      // Clean up dead
      balls=balls.filter(b=>!b.dead);
    }

    function draw(){
      ctx.clearRect(0,0,W,H);
      // Draw lines
      ctx.strokeStyle="rgba(255,215,0,0.6)";
      for(const [a,b] of lines){
        ctx.beginPath();
        ctx.moveTo(a.x,a.y);
        ctx.lineTo(b.x,b.y);
        ctx.stroke();
      }
      // Draw balls
      for(const b of balls){
        ctx.beginPath();
        if(b.supercell){
          ctx.strokeStyle="gold"; ctx.lineWidth=3;
          ctx.arc(b.x,b.y,b.r,0,Math.PI*2);
          ctx.stroke(); continue;
        }
        if(b.color==="lightgrey"){
          ctx.strokeStyle="lightgrey"; ctx.lineWidth=2;
          ctx.arc(b.x,b.y,b.r,0,Math.PI*2);
          ctx.stroke(); continue;
        }
        ctx.fillStyle=b.color==="doctor-green"?"lime":b.color;
        ctx.arc(b.x,b.y,b.r,0,Math.PI*2);
        ctx.fill();
      }
    }

    function loop(){
      update();
      draw();
      requestAnimationFrame(loop);
    }
    loop();

    // Initial spawn
    spawnBalls(20,"white");
  </script>
</body>
</html>
