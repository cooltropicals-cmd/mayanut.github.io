<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>MayaNut</title>
<style>
  :root{
    --ink:#eaf2ff; --ink-dim:#c6d0ea;
    --panel:rgba(12,16,34,.50); --line:rgba(255,255,255,.12);
    --accent:#8fdcff; --accent2:#c79bff;
    --inputBG:rgba(255,255,255,.08); --inputLine:rgba(255,255,255,.22);
  }
  html,body{height:100%}
  body{
    margin:0;color:var(--ink);
    font-family:Inter, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, "Helvetica Neue", Arial, sans-serif;
    display:flex;flex-direction:column;min-height:100%;
    background:
      radial-gradient(1000px 600px at 15% -10%, rgba(115,94,225,.35), transparent 60%),
      radial-gradient(1100px 700px at 85% 0%, rgba(168,78,255,.28), transparent 65%),
      radial-gradient(900px 500px at 50% 120%, rgba(34,124,255,.22), transparent 60%),
      linear-gradient(180deg, #081229 0%, #101a46 40%, #182263 100%);
    overflow-x:hidden;
  }

  .topbar{position:fixed;top:0;left:0;right:0;z-index:30;display:flex;align-items:center;justify-content:space-between;padding:10px 14px;background:var(--panel);border-bottom:1px solid var(--line);backdrop-filter:blur(10px)}
  .brand{font-weight:800;color:#fff;display:flex;align-items:center;gap:6px;user-select:none}
  .brand small{font-size:11px;opacity:.95;vertical-align:top}
  .brandInfo{position:absolute; top:42px; left:14px; font-size:12px; color:#dfe7ff; opacity:.9}
  .nav{display:flex;gap:18px;align-items:center}
  .nav a{color:var(--ink);text-decoration:none;font-weight:700;font-size:14px;padding:8px 12px;border-radius:10px}
  .nav a:hover{border:1px solid var(--line);background:rgba(255,255,255,.06)}

  .score{position:fixed; top:58px; right:12px; z-index:31; background:rgba(8,12,30,.7);
    border:1px solid var(--line); border-radius:12px; padding:6px 10px; font-size:13px;}

  .stage{flex:1;display:flex;align-items:center;justify-content:center;padding-top:88px;padding-bottom:80px}
  .panel{width:min(900px,92vw);text-align:center}
  .title{font-weight:900;font-size:clamp(44px,6vw,68px);line-height:1.05;color:#fff;margin:6px 0 14px}
  .title .glow{background:linear-gradient(90deg,var(--accent),var(--accent2));-webkit-background-clip:text;background-clip:text;color:transparent;}
  .chatbar{display:flex;align-items:center;gap:10px;justify-content:center;margin:0 auto;width:min(760px,92vw)}
  .chatbar input{flex:1;height:42px;padding:10px 12px;font-size:15px;color:#e9eeff;background:var(--inputBG);border:1px solid var(--inputLine);border-radius:12px;outline:none}
  .log{width:min(760px,92vw);margin:12px auto 0;background:rgba(8,12,30,.6);border:1px solid var(--line);border-radius:14px;padding:12px;max-height:42vh;overflow:auto}
  .msg{text-align:left;margin:6px 0;color:#eaf2ff}
  .msg strong{color:#cfe1ff}

  .section{width:min(980px,94vw);margin:24px auto 0;background:rgba(8,12,30,.55);border:1px solid var(--line);border-radius:16px;padding:18px}
  .section h3{margin:0 0 8px;color:#fff}
  .section p{margin:8px 0 0;color:#cfe9ff}

  footer{width:100%;color:#c9d3ef;border-top:1px solid var(--line);background:rgba(10,14,34,.55);text-align:center;font-size:13px;padding:12px 8px}

  #ballLayer{position:fixed;inset:0;z-index:9999;pointer-events:none}
</style>
</head>
<body>

<header class="topbar">
  <div class="brand">MayaNut<small>™</small></div>
  <div class="brandInfo">Balls: <b id="ballCount">1</b>/500</div>
  <nav class="nav">
    <a href="#home" id="navHome">MayaNut</a>
    <a href="#buy"  id="navBuy">Buy</a>
    <a href="#about" id="navAbout">About</a>
    <a href="https://instagram.com/mayanut.co" target="_blank" rel="noopener">Instagram</a>
  </nav>
</header>

<div id="scoreHUD" class="score">Score: <b id="score">0</b> <span id="pausedBadge" style="display:none;">· Paused</span></div>

<main id="home" class="stage">
  <div class="panel">
    <h1 id="heroTitle" class="title"><span class="glow">MayaNut</span><small>™</small></h1>
    <div class="chatbar"><input id="chatInput" placeholder="Type What You Want (try /spawn 20 small)" aria-label="Type what you want and press Enter" /></div>
    <div class="log" id="chatLog" aria-live="polite"></div>
  </div>
</main>

<section id="buy" class="section">
  <h3>Buy</h3>
  <p>Search Through Our Wonderful Products — real items coming soon.</p>
</section>

<section id="about" class="section">
  <h3>About</h3>
  <p><strong>MayaNut</strong> is a South Florida company promoting the cultivation and appreciation of
    <em>Brosimum alicastrum</em>—the Maya Nut (Breadnut). We champion sustainable agroforestry and regenerative
    farming that restores soils, supports biodiversity, and produces resilient, nutritious foods.</p>
  <p><strong>MayaNut was Founded on April 24, 2008.</strong></p>
</section>

<footer>© 2025 MayaNut LLC. All rights reserved.</footer>

<canvas id="ballLayer"></canvas>

<script>
/* ===== Chat + Commands + Space pause ===== */
const input = document.getElementById('chatInput');
const logBox = document.getElementById('chatLog');
const pausedBadge = document.getElementById('pausedBadge');
let GAME_PAUSED = false;

function say(role, text){
  const el=document.createElement('div'); el.className='msg';
  el.innerHTML=`<strong>${role}:</strong> ${text}`;
  logBox.appendChild(el); logBox.scrollTop=logBox.scrollHeight;
}
function setPaused(v){ GAME_PAUSED=!!v; pausedBadge.style.display = GAME_PAUSED ? '' : 'none'; }
function parseIntStrict(s, def){ const n=parseInt(s,10); return Number.isFinite(n)&&n>0?n:def; }

input.addEventListener('keydown', e=>{
  if(e.key==='Enter'){
    const raw=input.value.trim(); if(!raw) return; say('You', raw); input.value='';
    if (raw.startsWith('/')) { handleCommand(raw.slice(1)); return; }
    const low=raw.toLowerCase();
    if (low==='pause'){ setPaused(true); say('MayaNut','Paused. Type /resume or press Space.'); return; }
    if (['resume','unpause','continue'].includes(low)){ setPaused(false); say('MayaNut','Resumed.'); return; }
    if (low.includes('buy')||low.includes('product')){ say('MayaNut','Head to the Buy section (placeholders for now).'); document.getElementById('buy').scrollIntoView({behavior:'smooth'}); return; }
    if (low.includes('about')||low.includes('company')){ say('MayaNut','Scroll to About for more on MayaNut.'); document.getElementById('about').scrollIntoView({behavior:'smooth'}); return; }
    say('MayaNut',"Tell me what you want and I'll point you in the right direction.");
  }
});

document.addEventListener('keydown', (e)=>{
  if(e.code==='Space'){
    const ae=document.activeElement;
    if (ae && (ae===input || ae.tagName==='INPUT' || ae.tagName==='TEXTAREA')) return;
    e.preventDefault();
    setPaused(!GAME_PAUSED);
  }
});

function handleCommand(cmd){
  const parts = cmd.trim().split(/\s+/);
  const name = parts[0]?.toLowerCase();
  if (name==='pause'){ setPaused(true); say('MayaNut','Paused.'); return; }
  if (['resume','unpause','continue'].includes(name)){ setPaused(false); say('MayaNut','Resumed.'); return; }
  if (name==='spawn'){
    const n = parseIntStrict(parts[1], 1);
    const t = (parts[2]||'small').toLowerCase();
    const ok = window.GameSpawn(n, t);
    say('MayaNut', ok ? `Spawned ${ok} ${t}.` : 'Nothing spawned (at cap).');
    return;
  }
  if (name==='fill'){ const ok=window.GameFill(); say('MayaNut', `Filled with ${ok} small.`); return; }
  if (name==='clear'){ const c=window.GameClear(); say('MayaNut', `Cleared ${c} balls.`); return; }
  if (name==='red'){ const ok=window.GameSpawn(10,'red'); say('MayaNut', `Spawned ${ok} red.`); return; }
  say('MayaNut', 'Commands: /spawn N [small|spawner|factory|red], /fill, /clear, /pause, /resume');
}

/* ===== Game Engine (factories spawn orbiters; directional bonding) ===== */
(function(){
  const canvas=document.getElementById('ballLayer');
  const ctx=canvas.getContext('2d');
  function resize(){ canvas.width=innerWidth; canvas.height=innerHeight; }
  resize(); addEventListener('resize', resize);

  // Types
  const SMALL='small', SPAWNER='spawner', FACTORY='factory', RED='red';

  // Caps
  const MAX_BALLS=500;
  const RED_MAX=50;

  // Sizes
  const R_SMALL=3;     // tiny white dot
  const R_SPAWNER=16;  // medium w/ ring
  const R_FACTORY=26;  // biggest solid
  const R_RED=8;

  // Params
  const FACTORY_INTERVAL=200;     // factory spawn rate
  const ORBIT_RADIUS_PAD = 18;    // orbit gap from host edge
  const CHAIN_REPEL_MIN = 14;     // min spacing for bonded chains
  const CHAIN_REPEL_STRENGTH = 0.12;
  const SNAP_STRENGTH = 0.08;     // spring strength for bond points
  const SNAP_DAMP = 0.85;         // damping on snap correction
  const ANGLE_TOL = 0.52;         // ~30 degrees in radians

  // State
  const balls=[];      // all balls
  const chains=[];     // orbit-bonded small chains (still allowed)
  const links=[];      // explicit directional links for big-big & big-medium
  let score=0; const scoreEl=document.getElementById('score');
  const countEl=document.getElementById('ballCount');
  const aliveCount=()=>balls.filter(b=>!b._dead).length;
  const redCount=()=>balls.reduce((n,b)=>n+(!b._dead && b.type===RED?1:0),0);
  function updateCount(){ countEl.textContent=aliveCount(); }
  function addScore(n){ score+=n; scoreEl.textContent=score; }

  function makeBall(x,y,type=SMALL, vx=(Math.random()-.5)*2, vy=(Math.random()-.5)*2){
    const r = type===SMALL?R_SMALL : type===SPAWNER?R_SPAWNER : type===FACTORY?R_FACTORY : R_RED;
    return {
      x,y,vx,vy,r,type,_dead:false,
      orbit:null, chain:null,
      cooldown:0,
      bondedToFactory:false,
      hostFactory:null,
      // directional bond slots for FACTORY
      slots: type===FACTORY ? {top:null,bottom:null,left:null,right:null} : null,
      squashT:0, squashAxis:'x'
    };
  }
  function addBall(b){
    if (aliveCount()>=MAX_BALLS) return false;
    if (b.type===RED && redCount()>=RED_MAX) return false;
    balls.push(b); return true;
  }

  // Seed
  const seedFactory = makeBall(innerWidth*0.50, innerHeight*0.42, FACTORY, 0.6, 0.5);
  addBall(seedFactory);
  for(let i=0;i<14;i++) addBall(makeBall(Math.random()*innerWidth, Math.random()*innerHeight, SMALL));

  // Helpers
  function rects(){
    const els=[document.getElementById('heroTitle'), document.getElementById('chatInput'),
               document.getElementById('buy'), document.getElementById('about'), document.querySelector('.topbar')].filter(Boolean);
    return els.map(el=>{ const r=el.getBoundingClientRect(); return {x:r.left,y:r.top,w:r.width,h:r.height}; });
  }
  function collideRect(b,R){
    const nx=Math.max(R.x, Math.min(b.x, R.x+R.w));
    const ny=Math.max(R.y, Math.min(b.y, R.y+R.h));
    const dx=b.x-nx, dy=b.y-ny;
    if(dx*dx+dy*dy > b.r*b.r) return;
    const cx=R.x+R.w/2, cy=R.y+R.h/2;
    const ox=(R.w/2+b.r)-Math.abs(b.x-cx);
    const oy=(R.h/2+b.r)-Math.abs(b.y-cy);
    if(ox<oy){ b.vx*=-1; b.x+=(b.vx>0?1:-1)*Math.max(1,ox*0.6); b.squashT=10; b.squashAxis='x'; }
    else     { b.vy*=-1; b.y+=(b.vy>0?1:-1)*Math.max(1,oy*0.6); b.squashT=10; b.squashAxis='y'; }
  }
  function bounceWalls(b){
    if(b.x-b.r<0){ b.x=b.r; b.vx=Math.abs(b.vx); b.squashT=10; b.squashAxis='x'; }
    if(b.x+b.r>innerWidth){ b.x=innerWidth-b.r; b.vx=-Math.abs(b.vx); b.squashT=10; b.squashAxis='x'; }
    if(b.y-b.r<0){ b.y=b.r; b.vy=Math.abs(b.vy); b.squashT=10; b.squashAxis='y'; }
    if(b.y+b.r>innerHeight){ b.y=innerHeight-b.r; b.vy=-Math.abs(b.vy); b.squashT=10; b.squashAxis='y'; }
  }
  const nearAngle=(ang, target, tol=ANGLE_TOL)=>{
    let d = Math.abs(((ang - target + Math.PI) % (2*Math.PI)) - Math.PI);
    return d <= tol;
  };

  // Orbit-bond chains (smalls around same host)
  function bondOrbitersIfCollide(a,b){
    if(!(a.orbit && b.orbit)) return false;
    if(a.orbit !== b.orbit) return false;
    if(!a.chain && !b.chain){ const chain=[a,b]; a.chain=b.chain=chain; chains.push(chain); }
    else if(a.chain && !b.chain){ a.chain.push(b); b.chain=a.chain; }
    else if(!a.chain && b.chain){ b.chain.push(a); a.chain=b.chain; }
    a.orbit=b.orbit=null; a.vx=a.vy=b.vx=b.vy=0; return true;
  }
  function repelChains(){
    for(const ch of chains){
      const n=ch.length; if(n<2) continue;
      for(let i=0;i<n;i++) for(let j=i+1;j<n;j++){
        const a=ch[i], b=ch[j]; if(a._dead||b._dead) continue;
        const dx=b.x-a.x, dy=b.y-a.y, d=Math.hypot(dx,dy)||0.0001;
        const min=Math.max(CHAIN_REPEL_MIN,(a.r+b.r)*0.8);
        if(d<min){
          const push=(min-d)*CHAIN_REPEL_STRENGTH, nx=dx/d, ny=dy/d;
          a.x-=nx*push; a.y-=ny*push; b.x+=nx*push; b.y+=ny*push;
        }
      }
    }
  }

  // Directional links
  function addLink(a,b,slotA,slotB,dist){
    links.push({a,b,slotA,slotB,dist});
    if(a.slots && slotA) a.slots[slotA]=b;
    if(b.slots && slotB) b.slots[slotB]=a;
  }
  function snapLinks(){
    for(const L of links){
      const {a,b,slotA,slotB,dist}=L;
      if(a._dead||b._dead) continue;

      // desired anchors
      function anchorFor(node, slot){
        if(!node || node.type!==FACTORY) return {x:node.x,y:node.y};
        const r=node.r;
        if(slot==='top')    return {x:node.x, y:node.y - r};
        if(slot==='bottom') return {x:node.x, y:node.y + r};
        if(slot==='left')   return {x:node.x - r, y:node.y};
        if(slot==='right')  return {x:node.x + r, y:node.y};
        return {x:node.x,y:node.y};
      }
      const A = slotA?anchorFor(a,slotA):{x:a.x,y:a.y};
      const B = slotB?anchorFor(b,slotB):{x:b.x,y:b.y};

      // current vector
      let dx = (B.x - A.x), dy = (B.y - A.y);
      const d = Math.hypot(dx,dy) || 0.0001;
      const nx=dx/d, ny=dy/d;
      const target = dist;
      const err = d - target;

      // move each node half the error back along the axis (spring)
      const push = err * SNAP_STRENGTH;
      // apply to real centers
      a.x += nx*push; a.y += ny*push; a.vx *= SNAP_DAMP; a.vy *= SNAP_DAMP;
      b.x -= nx*push; b.y -= ny*push; b.vx *= SNAP_DAMP; b.vy *= SNAP_DAMP;
    }
  }

  // Collisions + promotions + directional bonding
  function handlePair(a,b){
    if(a._dead||b._dead) return;
    const dx=b.x-a.x, dy=b.y-a.y, d=Math.hypot(dx,dy);
    if(d>a.r+b.r) return;

    // Small + Small -> Spawner
    if(a.type===SMALL && b.type===SMALL){
      if(aliveCount()>=MAX_BALLS) return;
      a._dead=b._dead=true;
      addBall(makeBall((a.x+b.x)/2,(a.y+b.y)/2,SPAWNER,(a.vx+b.vx)/2,(a.vy+b.vy)/2));
      return;
    }

    // Spawner + Spawner -> Factory (only if neither bonded to a factory)
    if(a.type===SPAWNER && b.type===SPAWNER){
      if(!(a.bondedToFactory || b.bondedToFactory) && aliveCount()<MAX_BALLS){
        a._dead=b._dead=true;
        addBall(makeBall((a.x+b.x)/2,(a.y+b.y)/2,FACTORY,(a.vx+b.vx)/2,(a.vy+b.vy)/2));
        return;
      }
    }

    // Factory + Small → Small becomes Spawner (bonded to that factory)
    if((a.type===FACTORY && b.type===SMALL) || (b.type===FACTORY && a.type===SMALL)){
      const fac=a.type===FACTORY?a:b, sml=a.type===SMALL?a:b;
      sml.type=SPAWNER; sml.r=R_SPAWNER; sml.bondedToFactory=true; sml.hostFactory=fac;
      sml.orbit=null; sml.vx=sml.vy=0;
      const ang=Math.atan2(sml.y-fac.y,sml.x-fac.x), dist=fac.r+ORBIT_RADIUS_PAD;
      sml.x=fac.x+Math.cos(ang)*dist; sml.y=fac.y+Math.sin(ang)*dist;
      return;
    }

    // Small + (bonded) Spawner → another bonded Spawner (no factory promotion)
    if((a.type===SMALL && b.type===SPAWNER && b.bondedToFactory) ||
       (b.type===SMALL && a.type===SPAWNER && a.bondedToFactory)){
      const bonded = a.type===SPAWNER?a:b;
      const sml = a.type===SMALL?a:b;
      sml.type=SPAWNER; sml.r=R_SPAWNER; sml.bondedToFactory=true; sml.hostFactory=bonded.hostFactory||null;
      sml.orbit=null; sml.vx=sml.vy=0;
      const host = bonded.hostFactory || bonded;
      const ang=Math.random()*Math.PI*2, dist=(host.r + ORBIT_RADIUS_PAD + 8);
      sml.x=host.x+Math.cos(ang)*dist; sml.y=host.y+Math.sin(ang)*dist;
      return;
    }

    // Directional bonding:
    // 1) FACTORY–FACTORY only at TOP/BOTTOM (near vertical line)
    if(a.type===FACTORY && b.type===FACTORY){
      const ang = Math.atan2(dy,dx); // angle from a to b
      const sumR = a.r + b.r + 6;
      if(nearAngle(ang, Math.PI/2) && !a.slots.bottom && !b.slots.top){
        // b should sit below a
        addLink(a,b,'bottom','top',sumR);
        return;
      }
      if(nearAngle(ang, -Math.PI/2) && !a.slots.top && !b.slots.bottom){
        // b should sit above a
        addLink(a,b,'top','bottom',sumR);
        return;
      }
      // otherwise just bounce
    }

    // 2) FACTORY–SPAWNER only at LEFT/RIGHT of FACTORY (near horizontal line)
    if((a.type===FACTORY && b.type===SPAWNER) || (b.type===FACTORY && a.type===SPAWNER)){
      const fac = a.type===FACTORY?a:b;
      const spn = a.type===SPAWNER?a:b;
      const ang = Math.atan2(spn.y-fac.y, spn.x-fac.x);
      const sumR = fac.r + spn.r + 4;
      if(nearAngle(ang, 0) && !fac.slots.right){ // right side
        addLink(fac, spn, 'right', null, sumR);
        spn.bondedToFactory = true; spn.hostFactory = fac;
        return;
      }
      if(nearAngle(ang, Math.PI) && !fac.slots.left){ // left side
        addLink(fac, spn, 'left', null, sumR);
        spn.bondedToFactory = true; spn.hostFactory = fac;
        return;
      }
      // else: no bond; normal bounce below
    }

    // Orbiters around same host collide → make stagnant chain
    if (bondOrbitersIfCollide(a,b)) {
      a.squashT=b.squashT=10; a.squashAxis = Math.abs(dx)>Math.abs(dy)?'x':'y'; b.squashAxis=a.squashAxis;
      return;
    }

    // Red interactions (simple)
    if(a.type===RED || b.type===RED){
      const r = a.type===RED?a:b, o = a.type===RED?b:a;
      if(o.type===SMALL){ o._dead=true; } else { r.vx*=-0.9; r.vy*=-0.9; }
      r.squashT=10; r.squashAxis = Math.abs(dx)>Math.abs(dy)?'x':'y';
      return;
    }

    // Default elastic-ish bounce + squash
    const nx=dx/(d||1), ny=dy/(d||1);
    const p=(a.vx*nx+a.vy*ny - b.vx*nx - b.vy*ny);
    a.vx -= p*nx; a.vy -= p*ny; b.vx += p*nx; b.vy += p*ny;
    a.squashT=b.squashT=10; a.squashAxis = Math.abs(nx)>Math.abs(ny)?'x':'y'; b.squashAxis=a.squashAxis;
  }

  // Clicks: fold chain ends OR launch a hit ball
  document.addEventListener('click', e=>{
    if (e.target.closest('a,button,input,textarea,[contenteditable]')) return;
    const x=e.clientX, y=e.clientY;

    for(const ch of chains){
      if(ch.length>2){
        const f=ch[0], l=ch[ch.length-1];
        if(Math.hypot(f.x-x,f.y-y)<f.r+6 || Math.hypot(l.x-x,l.y-y)<l.r+6){
          const cx=ch.reduce((s,b)=>s+b.x,0)/ch.length, cy=ch.reduce((s,b)=>s+b.y,0)/ch.length;
          const radius=Math.max(18, ch.length*5);
          ch.forEach((b,i)=>{ const ang=(i/ch.length)*Math.PI*2; b.x=cx+Math.cos(ang)*radius; b.y=cy+Math.sin(ang)*radius; b.vx=b.vy=0; });
          addScore(1);
          return;
        }
      }
    }

    // launch any ball we clicked
    let hit=false;
    for(const b of balls){
      if(Math.hypot(b.x-x,b.y-y) < b.r+6){
        hit=true; const dx=b.x-x, dy=b.y-y, L=Math.hypot(dx,dy)||1;
        const kick=5.2; b.vx=(dx/L)*kick; b.vy=(dy/L)*kick;
        b.squashT=10; b.squashAxis = Math.abs(dx)>Math.abs(dy)?'x':'y';
        if (GAME_PAUSED){ b.x+=b.vx; b.y+=b.vy; }
      }
    }
    addScore(hit?1:-1);
  });

  // Public spawners for chat
  window.GameSpawn = function(n=1, type='small'){
    const t = type==='factory'?FACTORY : type==='spawner'?SPAWNER : type==='red'?RED : SMALL;
    let added=0;
    for(let i=0;i<n;i++){
      const atCap = aliveCount()>=MAX_BALLS || (t===RED && redCount()>=RED_MAX);
      if(atCap) break;
      const x=innerWidth*0.5 + (Math.random()*120-60);
      const y=innerHeight*0.45 + (Math.random()*120-60);
      if(addBall(makeBall(x,y,t))) added++;
    }
    updateCount();
    return added;
  };
  window.GameFill = function(){
    let added=0;
    while(aliveCount()<MAX_BALLS){
      if(!addBall(makeBall(Math.random()*innerWidth, Math.random()*innerHeight, SMALL))) break;
      added++;
    }
    updateCount(); return added;
  };
  window.GameClear = function(){
    const c=aliveCount(); balls.length=0; chains.length=0; links.length=0; updateCount(); return c;
  };

  function update(){
    if (GAME_PAUSED) return;
    const rs = rects();

    for(const b of balls){
      if(b._dead) continue;

      if(b.orbit){
        // orbit around host
        const c=b.orbit;
        const ang=Math.atan2(b.y-c.y,b.x-c.x)+0.05;
        const d=c.r + ORBIT_RADIUS_PAD;
        b.x=c.x+Math.cos(ang)*d;
        b.y=c.y+Math.sin(ang)*d;
        b.vx*=0.95; b.vy*=0.95;
      }else{
        b.x+=b.vx; b.y+=b.vy;
      }

      bounceWalls(b);
      for(const R of rs) collideRect(b,R);

      // Spawner/Factory attract nearby smalls into orbit
      if (b.type===SPAWNER || b.type===FACTORY){
        for(const s of balls){
          if(s._dead || s.type!==SMALL || s.orbit || s.chain) continue;
          const dist = Math.hypot(s.x-b.x, s.y-b.y);
          const desired = b.r + ORBIT_RADIUS_PAD;
          if (dist < desired + 14 && dist > desired - 22){
            s.orbit = b;
          }
        }
      }

      // Factories spawn smalls slowly
      if(b.type===FACTORY){
        b.cooldown++;
        if(b.cooldown>FACTORY_INTERVAL && aliveCount()<MAX_BALLS){
          b.cooldown=0;
          addBall(makeBall(b.x+(Math.random()*20-10), b.y+(Math.random()*20-10), SMALL));
        }
      }

      if (b.squashT>0) b.squashT--;
    }

    // collisions
    for(let i=0;i<balls.length;i++){
      for(let j=i+1;j<balls.length;j++){
        handlePair(balls[i], balls[j]);
      }
    }

    // spring snap for directional links
    snapLinks();
    // de-clump orbit chains
    repelChains();

    // cleanup
    for(let i=balls.length-1;i>=0;i--) if(balls[i]._dead) balls.splice(i,1);

    updateCount();
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // Draw explicit links first
    ctx.strokeStyle='rgba(255,255,255,0.55)';
    ctx.lineWidth=2;
    for(const L of links){
      const {a,b,slotA,slotB}=L;
      if(a._dead||b._dead) continue;

      function anchor(node, slot){
        if(!node || node.type!==FACTORY || !slot) return {x:node.x,y:node.y};
        const r=node.r;
        if(slot==='top')    return {x:node.x, y:node.y - r};
        if(slot==='bottom') return {x:node.x, y:node.y + r};
        if(slot==='left')   return {x:node.x - r, y:node.y};
        if(slot==='right')  return {x:node.x + r, y:node.y};
        return {x:node.x,y:node.y};
      }
      const A=anchor(a,slotA), B=anchor(b,slotB);
      ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke();
    }

    // Chains (stagnant links of smalls)
    ctx.strokeStyle='rgba(255,255,255,0.35)';
    ctx.lineWidth=1.5;
    for(const ch of chains){
      if(ch.length<2) continue;
      ctx.beginPath(); ctx.moveTo(ch[0].x,ch[0].y);
      for(const b of ch) ctx.lineTo(b.x,b.y);
      ctx.stroke();
    }

    // Balls with squash/stretch
    for(const b of balls){
      let sx=1, sy=1;
      if (b.squashT>0){
        const t=b.squashT/10, amt=0.35*Math.sin(t*Math.PI);
        if(b.squashAxis==='x'){ sx=1+amt; sy=1-amt; } else { sy=1+amt; sx=1-amt; }
      }
      ctx.save(); ctx.translate(b.x,b.y); ctx.scale(sx,sy);

      if(b.type===SMALL){
        ctx.fillStyle='#ffffff';
        ctx.beginPath(); ctx.arc(0,0,R_SMALL,0,Math.PI*2); ctx.fill();
      } else if(b.type===SPAWNER){
        ctx.fillStyle='#ffffff';
        ctx.beginPath(); ctx.arc(0,0,R_SPAWNER-2,0,Math.PI*2); ctx.fill();
        ctx.lineWidth=2; ctx.strokeStyle='rgba(255,255,255,0.9)';
        ctx.beginPath(); ctx.arc(0,0,R_SPAWNER,0,Math.PI*2); ctx.stroke();
      } else if(b.type===FACTORY){
        ctx.fillStyle='rgba(255,255,255,0.95)';
        ctx.beginPath(); ctx.arc(0,0,R_FACTORY,0,Math.PI*2); ctx.fill();

        // little marks for available slots (subtle)
        ctx.strokeStyle='rgba(255,255,255,0.35)'; ctx.lineWidth=1;
        if(!b.slots.top){    ctx.beginPath(); ctx.moveTo(0,-R_FACTORY); ctx.lineTo(0,-R_FACTORY-6); ctx.stroke(); }
        if(!b.slots.bottom){ ctx.beginPath(); ctx.moveTo(0,R_FACTORY);  ctx.lineTo(0,R_FACTORY+6); ctx.stroke(); }
        if(!b.slots.left){   ctx.beginPath(); ctx.moveTo(-R_FACTORY,0); ctx.lineTo(-R_FACTORY-6,0); ctx.stroke(); }
        if(!b.slots.right){  ctx.beginPath(); ctx.moveTo(R_FACTORY,0);  ctx.lineTo(R_FACTORY+6,0); ctx.stroke(); }
      } else if(b.type===RED){
        ctx.fillStyle='#ff4d4d';
        ctx.beginPath(); ctx.arc(0,0,R_RED,0,Math.PI*2); ctx.fill();
      }

      ctx.restore();
    }
  }

  // Click handling (folding chains + launching) is in the outer scope:
  function loop(){ update(); draw(); requestAnimationFrame(loop); }
  loop();
})();
</script>
</body>
</html>
