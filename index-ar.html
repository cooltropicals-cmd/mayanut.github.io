<script>
(function(){
  const canvas = document.getElementById('ballLayer');
  const ctx = canvas.getContext('2d');
  function resize(){
    canvas.width = innerWidth;
    canvas.height = innerHeight;
  }
  resize();
  addEventListener('resize', resize);

  const cells = [];
  const chains = [];
  const BASE_CAP = 250;
  const FACTORY_INTERVAL = 200; // frames before factories spawn new small cells

  // Types
  const SMALL = 'small';
  const SPAWNER = 'spawner';
  const FACTORY = 'factory';

  function makeCell(x, y, type=SMALL){
    let r = type===SMALL?6:type===SPAWNER?12:20;
    return {
      x,y,
      vx:(Math.random()-.5)*2,
      vy:(Math.random()-.5)*2,
      r,
      type,
      orbiting:null,
      chain:null,
      cooldown:0
    };
  }

  // Spawn some initial small cells
  for(let i=0;i<20;i++){
    cells.push(makeCell(Math.random()*innerWidth, Math.random()*innerHeight, SMALL));
  }

  // Clicking cells: launch them away
  canvas.addEventListener('click', e=>{
    const mx=e.clientX, my=e.clientY;
    for(const c of cells){
      const d=Math.hypot(mx-c.x,my-c.y);
      if(d<c.r+4){
        c.vx = (c.x-mx)*0.1;
        c.vy = (c.y-my)*0.1;
      }
    }
    // Check chain ends folding
    for(const chain of chains){
      if(chain.length>2){
        const first=chain[0], last=chain[chain.length-1];
        if(Math.hypot(first.x-mx,first.y-my)<first.r+5 ||
           Math.hypot(last.x-mx,last.y-my)<last.r+5){
          // fold into circle
          const cx=chain.reduce((s,b)=>s+b.x,0)/chain.length;
          const cy=chain.reduce((s,b)=>s+b.y,0)/chain.length;
          const radius=chain.length*4;
          chain.forEach((b,i)=>{
            const angle=(i/chain.length)*Math.PI*2;
            b.x=cx+Math.cos(angle)*radius;
            b.y=cy+Math.sin(angle)*radius;
            b.vx=b.vy=0;
          });
        }
      }
    }
  });

  function update(){
    // Move cells
    for(const c of cells){
      c.x+=c.vx; c.y+=c.vy;
      if(c.x<c.r||c.x>innerWidth-c.r) c.vx*=-1;
      if(c.y<c.r||c.y>innerHeight-c.r) c.vy*=-1;
    }

    // Collisions
    for(let i=0;i<cells.length;i++){
      for(let j=i+1;j<cells.length;j++){
        const a=cells[i], b=cells[j];
        const d=Math.hypot(a.x-b.x,a.y-b.y);
        if(d<a.r+b.r){
          // small+small -> spawner
          if(a.type===SMALL && b.type===SMALL){
            a.type=b.type=SPAWNER;
            a.r=b.r=12;
          }
          // spawner+spawner -> factory
          if(a.type===SPAWNER && b.type===SPAWNER){
            a.type=b.type=FACTORY;
            a.r=b.r=20;
          }
          // orbiting: small orbits big
          if(a.type===SMALL && (b.type===SPAWNER||b.type===FACTORY)) a.orbiting=b;
          if(b.type===SMALL && (a.type===SPAWNER||a.type===FACTORY)) b.orbiting=a;

          // orbiters collide -> chain
          if(a.orbiting && b.orbiting && a.orbiting===b.orbiting){
            if(!a.chain && !b.chain){
              const chain=[a,b];
              a.chain=b.chain=chain;
              chains.push(chain);
            } else if(a.chain && !b.chain){
              a.chain.push(b); b.chain=a.chain;
            } else if(!a.chain && b.chain){
              b.chain.push(a); a.chain=b.chain;
            }
          }
        }
      }
    }

    // Orbit motion
    for(const c of cells){
      if(c.orbiting){
        const center=c.orbiting;
        const angle=Math.atan2(c.y-center.y,c.x-center.x)+0.05;
        const dist=center.r+20;
        c.x=center.x+Math.cos(angle)*dist;
        c.y=center.y+Math.sin(angle)*dist;
      }
    }

    // Factory spawn small cells
    for(const c of cells){
      if(c.type===FACTORY){
        c.cooldown++;
        if(c.cooldown>FACTORY_INTERVAL && cells.length<BASE_CAP){
          c.cooldown=0;
          cells.push(makeCell(c.x+Math.random()*20-10,c.y+Math.random()*20-10,SMALL));
        }
      }
    }
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // Draw chains first
    ctx.strokeStyle='rgba(255,255,255,0.5)';
    for(const chain of chains){
      ctx.beginPath();
      ctx.moveTo(chain[0].x,chain[0].y);
      for(const c of chain) ctx.lineTo(c.x,c.y);
      ctx.stroke();
    }
    // Draw cells
    for(const c of cells){
      ctx.beginPath();
      ctx.fillStyle=c.type===SMALL?'white':c.type===SPAWNER?'orange':'red';
      ctx.arc(c.x,c.y,c.r,0,Math.PI*2);
      ctx.fill();
    }
  }

  function loop(){
    update();
    draw();
    requestAnimationFrame(loop);
  }
  loop();
})();
</script>

