<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>MayaNut</title>
<style>
  :root{
    --ink:#eaf2ff; --ink-dim:#c6d0ea;
    --panel:rgba(12,16,34,.50); --line:rgba(255,255,255,.12);
    --accent:#8fdcff; --accent2:#c79bff;
    --inputBG:rgba(255,255,255,.08); --inputLine:rgba(255,255,255,.22);
  }
  html,body{height:100%}
  body{
    margin:0;color:var(--ink);
    font-family:Inter, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, "Helvetica Neue", Arial, sans-serif;
    display:flex;flex-direction:column;min-height:100%;
    background:
      radial-gradient(1000px 600px at 15% -10%, rgba(115,94,225,.35), transparent 60%),
      radial-gradient(1100px 700px at 85% 0%, rgba(168,78,255,.28), transparent 65%),
      radial-gradient(900px 500px at 50% 120%, rgba(34,124,255,.22), transparent 60%),
      linear-gradient(180deg, #081229 0%, #101a46 40%, #182263 100%);
    overflow-x:hidden;
  }

  .topbar{position:fixed;top:0;left:0;right:0;z-index:30;display:flex;align-items:center;justify-content:space-between;padding:10px 14px;background:var(--panel);border-bottom:1px solid var(--line);backdrop-filter:blur(10px)}
  .brand{font-weight:800;color:#fff;display:flex;align-items:center;gap:6px;user-select:none}
  .brand small{font-size:11px;opacity:.95;vertical-align:top}
  .brandInfo{position:absolute; top:42px; left:14px; font-size:12px; color:#dfe7ff; opacity:.9}
  .nav{display:flex;gap:18px;align-items:center}
  .nav a{color:var(--ink);text-decoration:none;font-weight:700;font-size:14px;padding:8px 12px;border-radius:10px}
  .nav a:hover{border:1px solid var(--line);background:rgba(255,255,255,.06)}

  .score{position:fixed; top:58px; right:12px; z-index:31; background:rgba(8,12,30,.7);
    border:1px solid var(--line); border-radius:12px; padding:6px 10px; font-size:13px;}

  .stage{flex:1;display:flex;align-items:center;justify-content:center;padding-top:88px;padding-bottom:80px}
  .panel{width:min(900px,92vw);text-align:center}
  .title{font-weight:900;font-size:clamp(44px,6vw,68px);line-height:1.05;color:#fff;margin:6px 0 14px}
  .title .glow{background:linear-gradient(90deg,var(--accent),var(--accent2));-webkit-background-clip:text;background-clip:text;color:transparent;}
  .chatbar{display:flex;align-items:center;gap:10px;justify-content:center;margin:0 auto;width:min(760px,92vw)}
  .chatbar input{flex:1;height:42px;padding:10px 12px;font-size:15px;color:#e9eeff;background:var(--inputBG);border:1px solid var(--inputLine);border-radius:12px;outline:none}
  .log{width:min(760px,92vw);margin:12px auto 0;background:rgba(8,12,30,.6);border:1px solid var(--line);border-radius:14px;padding:12px;max-height:42vh;overflow:auto}
  .msg{text-align:left;margin:6px 0;color:#eaf2ff}
  .msg strong{color:#cfe1ff}

  .section{width:min(980px,94vw);margin:24px auto 0;background:rgba(8,12,30,.55);border:1px solid var(--line);border-radius:16px;padding:18px}
  .section h3{margin:0 0 8px;color:#fff}
  .section p{margin:8px 0 0;color:#cfe9ff}

  footer{width:100%;color:#c9d3ef;border-top:1px solid var(--line);background:rgba(10,14,34,.55);text-align:center;font-size:13px;padding:12px 8px}

  /* Canvas: clicks are on document; keep canvas non-interactive */
  #ballLayer{position:fixed;inset:0;z-index:9999;pointer-events:none}
</style>
</head>
<body>

<header class="topbar">
  <div class="brand">MayaNut<small>™</small></div>
  <div class="brandInfo">Balls: <b id="ballCount">1</b>/500</div>
  <nav class="nav">
    <a href="#home" id="navHome">MayaNut</a>
    <a href="#buy"  id="navBuy">Buy</a>
    <a href="#about" id="navAbout">About</a>
    <a href="https://instagram.com/mayanut.co" target="_blank" rel="noopener">Instagram</a>
  </nav>
</header>

<div id="scoreHUD" class="score">Score: <b id="score">0</b> <span id="pausedBadge" style="display:none;">· Paused</span></div>

<main id="home" class="stage">
  <div class="panel">
    <h1 id="heroTitle" class="title"><span class="glow">MayaNut</span><small>™</small></h1>
    <div class="chatbar"><input id="chatInput" placeholder="Type What You Want (try /spawn 6 factory)" aria-label="Type what you want and press Enter" /></div>
    <div class="log" id="chatLog" aria-live="polite"></div>
  </div>
</main>

<section id="buy" class="section">
  <h3>Buy</h3>
  <p>Search Through Our Wonderful Products — real items coming soon.</p>
</section>

<section id="about" class="section">
  <h3>About</h3>
  <p><strong>MayaNut</strong> is a South Florida company promoting the cultivation and appreciation of
    <em>Brosimum alicastrum</em>—the Maya Nut (Breadnut). We champion sustainable agroforestry and regenerative
    farming that restores soils, supports biodiversity, and produces resilient, nutritious foods.</p>
  <p><strong>MayaNut was Founded on April 24, 2008.</strong></p>
</section>

<footer>© 2025 MayaNut LLC. All rights reserved.</footer>

<canvas id="ballLayer"></canvas>

<script>
/* ===== Chat + Commands + Space pause ===== */
const input = document.getElementById('chatInput');
const logBox = document.getElementById('chatLog');
const pausedBadge = document.getElementById('pausedBadge');
let GAME_PAUSED = false;

function say(role, text){
  const el=document.createElement('div'); el.className='msg';
  el.innerHTML=`<strong>${role}:</strong> ${text}`;
  logBox.appendChild(el); logBox.scrollTop=logBox.scrollHeight;
}
function setPaused(v){ GAME_PAUSED=!!v; pausedBadge.style.display = GAME_PAUSED ? '' : 'none'; }
function parseIntStrict(s, def){ const n=parseInt(s,10); return Number.isFinite(n)&&n>0?n:def; }

input.addEventListener('keydown', e=>{
  if(e.key==='Enter'){
    const raw=input.value.trim(); if(!raw) return; say('You', raw); input.value='';
    if (raw.startsWith('/')) { handleCommand(raw.slice(1)); return; }
    const low=raw.toLowerCase();
    if (low==='pause'){ setPaused(true); say('MayaNut','Paused. Type /resume or press Space.'); return; }
    if (['resume','unpause','continue'].includes(low)){ setPaused(false); say('MayaNut','Resumed.'); return; }
    if (low.includes('buy')||low.includes('product')){ say('MayaNut','Head to the Buy section (placeholders for now).'); document.getElementById('buy').scrollIntoView({behavior:'smooth'}); return; }
    if (low.includes('about')||low.includes('company')){ say('MayaNut','Scroll to About for more on MayaNut.'); document.getElementById('about').scrollIntoView({behavior:'smooth'}); return; }
    say('MayaNut',"Tell me what you want and I'll point you in the right direction.");
  }
});

document.addEventListener('keydown', (e)=>{
  if(e.code==='Space'){
    const ae=document.activeElement;
    if (ae && (ae===input || ae.tagName==='INPUT' || ae.tagName==='TEXTAREA')) return;
    e.preventDefault();
    setPaused(!GAME_PAUSED);
  }
});

function handleCommand(cmd){
  const parts = cmd.trim().split(/\s+/);
  const name = parts[0]?.toLowerCase();
  if (name==='pause'){ setPaused(true); say('MayaNut','Paused.'); return; }
  if (['resume','unpause','continue'].includes(name)){ setPaused(false); say('MayaNut','Resumed.'); return; }
  if (name==='spawn'){
    const n = parseIntStrict(parts[1], 1);
    const t = (parts[2]||'small').toLowerCase();
    const ok = window.GameSpawn(n, t);
    say('MayaNut', ok ? `Spawned ${ok} ${t}.` : 'Nothing spawned (at cap).');
    return;
  }
  if (name==='fill'){ const ok=window.GameFill(); say('MayaNut', `Filled with ${ok} small.`); return; }
  if (name==='clear'){ const c=window.GameClear(); say('MayaNut', `Cleared ${c} balls.`); return; }
  if (name==='red'){ const ok=window.GameSpawn(10,'red'); say('MayaNut', `Spawned ${ok} red.`); return; }
  say('MayaNut', 'Commands: /spawn N [small|spawner|factory|triad|red], /fill, /clear, /pause, /resume');
}

/* ===== Game Engine (TRIADs form + TRIAD↔TRIAD bonding N/S) ===== */
(function(){
  const canvas=document.getElementById('ballLayer');
  const ctx=canvas.getContext('2d');
  function resize(){ canvas.width=innerWidth; canvas.height=innerHeight; }
  resize(); addEventListener('resize', resize);

  // Types
  const SMALL='small', SPAWNER='spawner', FACTORY='factory', TRIAD='triad', RED='red';

  // Caps
  const MAX_BALLS=500;
  const RED_MAX=50;

  // Sizes
  const R_SMALL=3;       // tiny white dot
  const R_SPAWNER=16;    // medium w/ ring
  const R_FACTORY=26;    // biggest solid
  const R_TRIAD=28;      // triad main (slightly larger for visual)
  const R_RED=8;

  // Params
  const FACTORY_INTERVAL=200;   // factory spawn rate (littles)
  const TRIAD_INTERVAL=260;     // triad also drips littles, a bit slower
  const ORBIT_RADIUS_PAD=18;
  const ANGLE_TOL=0.38;         // ~22° gate for N/S bonds
  const LINK_STIFF=0.10;        // spring stiffness for links
  const LINK_DAMP=0.85;         // damping for linked nodes
  const STRING_SPACING_F = R_FACTORY*2.05;
  const STRING_SPACING_T = R_TRIAD*2.05;
  const RING_CLOSE_DIST_F = R_FACTORY*1.8;
  const RING_CLOSE_DIST_T = R_TRIAD*1.8;

  // State
  const balls=[];         // dynamic parts (including TRIAD as a single body)
  const links=[];         // springs between FACTORY/ TRIAD nodes (N/S only)
  const fChains=new Map(); // chainId -> array of nodes (FACTORY or TRIAD)
  let nextChainId=1;

  let score=0; const scoreEl=document.getElementById('score');
  const countEl=document.getElementById('ballCount');
  const aliveCount=()=>balls.filter(b=>!b._dead).length;
  const redCount=()=>balls.reduce((n,b)=>n+(!b._dead && b.type===RED?1:0),0);
  function updateCount(){ countEl.textContent=aliveCount(); }
  function addScore(n){ score+=n; scoreEl.textContent=score; }

  function makeBall(x,y,type=SMALL, vx=(Math.random()-.5)*2, vy=(Math.random()-.5)*2){
    let r = R_SMALL;
    if (type===SPAWNER) r=R_SPAWNER;
    else if (type===FACTORY) r=R_FACTORY;
    else if (type===TRIAD) r=R_TRIAD;
    else if (type===RED) r=R_RED;

    const base = {x,y,vx,vy,r,type,_dead:false,
                  orbit:null, cooldown:0, squashT:0, squashAxis:'x'};
    // Node-only metadata
    if (type===FACTORY || type===TRIAD){
      base.slots = {top:null,bottom:null};
      base.chainId = null; base.isRing=false;
      if (type===TRIAD){
        // visual sub-parts offsets (relative)
        base.middleOffset = {x: r*0.75, y: 0}; // where the "medium" sits on shell
        base.innerDot = true;                  // draw little core dot
      }
    }
    return base;
  }
  function addBall(b){
    if (aliveCount()>=MAX_BALLS) return false;
    if (b.type===RED && redCount()>=RED_MAX) return false;
    balls.push(b); return true;
  }

  // Seed: a factory and some smalls to see fusion
  addBall(makeBall(innerWidth*0.46, innerHeight*0.42, FACTORY, 0.8, 0.6));
  for(let i=0;i<14;i++) addBall(makeBall(Math.random()*innerWidth, Math.random()*innerHeight, SMALL));

  // UI rects to bounce off
  function rects(){
    const els=[document.getElementById('heroTitle'), document.getElementById('chatInput'),
               document.getElementById('buy'), document.getElementById('about'), document.querySelector('.topbar')].filter(Boolean);
    return els.map(el=>{ const r=el.getBoundingClientRect(); return {x:r.left,y:r.top,w:r.width,h:r.height}; });
  }
  function collideRect(b,R){
    const nx=Math.max(R.x, Math.min(b.x, R.x+R.w));
    const ny=Math.max(R.y, Math.min(b.y, R.y+R.h));
    const dx=b.x-nx, dy=b.y-ny;
    if(dx*dx+dy*dy > b.r*b.r) return;
    const cx=R.x+R.w/2, cy=R.y+R.h/2;
    const ox=(R.w/2+b.r)-Math.abs(b.x-cx);
    const oy=(R.h/2+b.r)-Math.abs(b.y-cy);
    if(ox<oy){ b.vx*=-1; b.x+=(b.vx>0?1:-1)*Math.max(1,ox*0.6); b.squashT=10; b.squashAxis='x'; }
    else     { b.vy*=-1; b.y+=(b.vy>0?1:-1)*Math.max(1,oy*0.6); b.squashT=10; b.squashAxis='y'; }
  }

  function bounceWalls(b){
    if(b.x-b.r<0){ b.x=b.r; b.vx=Math.abs(b.vx); b.squashT=10; b.squashAxis='x'; }
    if(b.x+b.r>innerWidth){ b.x=innerWidth-b.r; b.vx=-Math.abs(b.vx); b.squashT=10; b.squashAxis='x'; }
    if(b.y-b.r<0){ b.y=b.r; b.vy=Math.abs(b.vy); b.squashT=10; b.squashAxis='y'; }
    if(b.y+b.r>innerHeight){ b.y=innerHeight-b.r; b.vy=-Math.abs(b.vy); b.squashT=10; b.squashAxis='y'; }
  }

  // Helpers for node links
  const nearAngle=(ang, target, tol=ANGLE_TOL)=>{
    let d = Math.abs(((ang - target + Math.PI) % (2*Math.PI)) - Math.PI);
    return d <= tol;
  };
  function anchor(node, slot){
    if(slot==='top')    return {x:node.x, y:node.y - node.r};
    if(slot==='bottom') return {x:node.x, y:node.y + node.r};
    return {x:node.x,y:node.y};
  }

  function ensureChainFor(n){
    if (n.chainId!=null) return n.chainId;
    const id=nextChainId++; n.chainId=id; fChains.set(id,[n]); return id;
  }
  function mergeChains(idA, idB){
    if (idA===idB) return idA;
    const A=fChains.get(idA)||[], B=fChains.get(idB)||[];
    const merged=[...A,...B]; const newId=nextChainId++;
    for(const n of merged){ n.chainId=newId; }
    fChains.delete(idA); fChains.delete(idB); fChains.set(newId, merged);
    return newId;
  }
  function appendToChain(anchorN, newN, at='bottom'){
    const id=ensureChainFor(anchorN);
    const arr=fChains.get(id);
    if (at==='bottom') arr.push(newN); else arr.unshift(newN);
    newN.chainId=id;
  }

  function addLink(a,b,slotA,slotB,dist){
    links.push({a,b,slotA,slotB,dist});
    if (a.slots) a.slots[slotA]=b;
    if (b.slots) b.slots[slotB]=a;
  }
  function snapLinks(){
    for(const L of links){
      const {a,b,slotA,slotB,dist}=L;
      if(a._dead||b._dead) continue;
      const A=anchor(a,slotA), B=anchor(b,slotB);
      const dx=B.x-A.x, dy=B.y-A.y;
      const d=Math.hypot(dx,dy)||0.0001, nx=dx/d, ny=dy/d;
      const err=d - dist;
      const push=err*LINK_STIFF;
      a.x += nx*push; a.y += ny*push; a.vx *= LINK_DAMP; a.vy *= LINK_DAMP;
      b.x -= nx*push; b.y -= ny*push; b.vx *= LINK_DAMP; b.vy *= LINK_DAMP;
    }
  }

  function tryCloseRings(){
    for (const [id, arr] of [...fChains]){
      if (arr.length<4) continue;
      const first=arr[0], last=arr[arr.length-1];
      if (!first || !last || first._dead || last._dead) continue;
      const dx=last.x-first.x, dy=last.y-first.y;
      // choose ring threshold by node type
      const thresh = (first.type===TRIAD || last.type===TRIAD) ? RING_CLOSE_DIST_T : RING_CLOSE_DIST_F;
      if (Math.hypot(dx,dy) <= thresh){
        const cx = arr.reduce((s,n)=>s+n.x,0)/arr.length;
        const cy = arr.reduce((s,n)=>s+n.y,0)/arr.length;
        const spacing = (arr.some(n=>n.type===TRIAD)?STRING_SPACING_T:STRING_SPACING_F);
        const radius = Math.max(R_FACTORY*1.5, (arr.length*spacing)/(2*Math.PI));
        for(let i=0;i<arr.length;i++){
          const ang = (i/arr.length)*Math.PI*2;
          const n = arr[i];
          n.x = cx + Math.cos(ang)*radius;
          n.y = cy + Math.sin(ang)*radius;
          n.vx = n.vy = 0;
          n.isRing = true;
        }
      }
    }
  }

  // TRIAD formation: Factory + Spawner overlapping, with a Small inside Factory
  function maybeFormTriad(a,b){
    let F=null, M=null; // F=Factory, M=Spawner
    if (a.type===FACTORY && b.type===SPAWNER) { F=a; M=b; }
    else if (b.type===FACTORY && a.type===SPAWNER) { F=b; M=a; }
    else return false;

    // look for a little that is inside the Factory's disk
    let innerIndex=-1;
    for(let i=0;i<balls.length;i++){
      const s=balls[i]; if(s._dead || s.type!==SMALL) continue;
      if (Math.hypot(s.x-F.x, s.y-F.y) <= F.r - R_SMALL*0.5){ innerIndex=i; break; }
    }
    if (innerIndex<0) return false;

    // Replace Factory+Spawner+Small with one TRIAD at Factory position
    const S=balls[innerIndex];
    F._dead=true; M._dead=true; S._dead=true;

    const T=makeBall(F.x, F.y, TRIAD, (F.vx+M.vx)/2, (F.vy+M.vy)/2);
    // inherit modest momentum, keep slots free for N/S bonds
    addBall(T);
    return true;
  }

  // Collisions & behaviors
  function handlePair(a,b){
    if(a._dead||b._dead) return;
    const dx=b.x-a.x, dy=b.y-a.y, d=Math.hypot(dx,dy);
    if(d>a.r+b.r) return;

    // Small + Small -> Spawner
    if(a.type===SMALL && b.type===SMALL){
      if(aliveCount()>=MAX_BALLS) return;
      a._dead=b._dead=true;
      addBall(makeBall((a.x+b.x)/2,(a.y+b.y)/2,SPAWNER,(a.vx+b.vx)/2,(a.vy+b.vy)/2));
      return;
    }

    // Spawner + Spawner -> Factory
    if(a.type===SPAWNER && b.type===SPAWNER){
      if(aliveCount()>=MAX_BALLS) return;
      a._dead=b._dead=true;
      addBall(makeBall((a.x+b.x)/2,(a.y+b.y)/2,FACTORY,(a.vx+b.vx)/2,(a.vy+b.vy)/2));
      return;
    }

    // Try to form a TRIAD first (Factory+Spawner with Small inside)
    if (maybeFormTriad(a,b)) return;

    // Orbit capture: smalls near factory/spawner/triad
    if(a.type===SMALL && (b.type===SPAWNER||b.type===FACTORY||b.type===TRIAD)) a.orbit=b;
    if(b.type===SMALL && (a.type===SPAWNER||a.type===FACTORY||a.type===TRIAD)) b.orbit=a;

    // Node–Node bonds (FACTORY or TRIAD) — only N/S linking to avoid clumps
    const AisNode = (a.type===FACTORY||a.type===TRIAD);
    const BisNode = (b.type===FACTORY||b.type===TRIAD);
    if (AisNode && BisNode){
      const ang = Math.atan2(dy,dx);
      const spacing = (a.type===TRIAD||b.type===TRIAD) ? STRING_SPACING_T : STRING_SPACING_F;

      // b below a => a.bottom ↔ b.top
      if (nearAngle(ang, Math.PI/2) && !a.slots.bottom && !b.slots.top){
        addLink(a,b,'bottom','top',spacing);
        const idA=ensureChainFor(a), idB=ensureChainFor(b);
        const id=(idA===idB)?idA:mergeChains(idA,idB);
        const arr=fChains.get(id);
        if (arr.indexOf(a)>-1 && arr.indexOf(b)===-1){ arr.splice(arr.indexOf(a)+1,0,b); b.chainId=id; }
        return;
      }
      // b above a => a.top ↔ b.bottom
      if (nearAngle(ang, -Math.PI/2) && !a.slots.top && !b.slots.bottom){
        addLink(a,b,'top','bottom',spacing);
        const idA=ensureChainFor(a), idB=ensureChainFor(b);
        const id=(idA===idB)?idA:mergeChains(idA,idB);
        const arr=fChains.get(id);
        if (arr.indexOf(a)>-1 && arr.indexOf(b)===-1){ arr.splice(Math.max(0,arr.indexOf(a)),0,b); b.chainId=id; }
        return;
      }
    }

    // Reds (simple)
    if(a.type===RED || b.type===RED){
      const r = a.type===RED?a:b, o = a.type===RED?b:a;
      if(o.type===SMALL){ o._dead=true; } else { r.vx*=-0.9; r.vy*=-0.9; }
      r.squashT=10; r.squashAxis = Math.abs(dx)>Math.abs(dy)?'x':'y';
      return;
    }

    // Default elastic-ish bounce + squash
    const nx=dx/(d||1), ny=dy/(d||1);
    const p=(a.vx*nx+a.vy*ny - b.vx*nx - b.vy*ny);
    a.vx -= p*nx; a.vy -= p*ny; b.vx += p*nx; b.vy += p*ny;
    a.squashT=b.squashT=10; a.squashAxis = Math.abs(nx)>Math.abs(ny)?'x':'y'; b.squashAxis=a.squashAxis;
  }

  // Clicks: launch the ball you hit
  document.addEventListener('click', e=>{
    if (e.target.closest('a,button,input,textarea,[contenteditable]')) return;
    const x=e.clientX, y=e.clientY;
    let hit=false;
    for(const b of balls){
      if(Math.hypot(b.x-x,b.y-y) < b.r+6){
        hit=true; const dx=b.x-x, dy=b.y-y, L=Math.hypot(dx,dy)||1;
        const kick=5.2; b.vx=(dx/L)*kick; b.vy=(dy/L)*kick;
        b.squashT=10; b.squashAxis = Math.abs(dx)>Math.abs(dy)?'x':'y';
        if (GAME_PAUSED){ b.x+=b.vx; b.y+=b.vy; }
      }
    }
    addScore(hit?1:-1);
  });

  // Public spawners for chat
  window.GameSpawn = function(n=1, type='small'){
    const t = type==='factory'?FACTORY : type==='spawner'?SPAWNER : type==='triad'?TRIAD : type==='red'?RED : SMALL;
    let added=0;
    for(let i=0;i<n;i++){
      const atCap = aliveCount()>=MAX_BALLS || (t===RED && redCount()>=RED_MAX);
      if(atCap) break;
      const x=innerWidth*0.5 + (Math.random()*120-60);
      const y=innerHeight*0.45 + (Math.random()*120-60);
      if(addBall(makeBall(x,y,t))) added++;
    }
    updateCount();
    return added;
  };
  window.GameFill = function(){
    let added=0;
    while(aliveCount()<MAX_BALLS){
      if(!addBall(makeBall(Math.random()*innerWidth, Math.random()*innerHeight, SMALL))) break;
      added++;
    }
    updateCount(); return added;
  };
  window.GameClear = function(){
    const c=aliveCount(); balls.length=0; links.length=0; fChains.clear(); updateCount(); return c;
  };

  function update(){
    if (GAME_PAUSED) return;
    const rs = rects();

    for(const b of balls){
      if(b._dead) continue;

      // orbiting motion for captured smalls — clamp to shell to avoid getting “inside”
      if(b.type===SMALL && b.orbit){
        const c=b.orbit;
        let ang=Math.atan2(b.y-c.y,b.x-c.x)+0.05;
        const desired = c.r + ORBIT_RADIUS_PAD;
        b.x=c.x+Math.cos(ang)*desired;
        b.y=c.y+Math.sin(ang)*desired;
        b.vx*=0.92; b.vy*=0.92;
      }else{
        b.x+=b.vx; b.y+=b.vy;
      }

      bounceWalls(b);
      for(const R of rs) collideRect(b,R);

      // spawning
      if(b.type===FACTORY){
        b.cooldown++;
        if(b.cooldown>FACTORY_INTERVAL && aliveCount()<MAX_BALLS){
          b.cooldown=0;
          addBall(makeBall(b.x+(Math.random()*20-10), b.y+(Math.random()*20-10), SMALL));
        }
      }
      if(b.type===TRIAD){
        b.cooldown++;
        if(b.cooldown>TRIAD_INTERVAL && aliveCount()<MAX_BALLS){
          b.cooldown=0;
          addBall(makeBall(b.x+(Math.random()*20-10), b.y+(Math.random()*20-10), SMALL));
        }
      }

      if (b.squashT>0) b.squashT--;
    }

    // collisions
    for(let i=0;i<balls.length;i++){
      for(let j=i+1;j<balls.length;j++){
        handlePair(balls[i], balls[j]);
      }
    }

    // keep node strings tidy and try forming rings
    snapLinks();
    tryCloseRings();

    // cleanup
    for(let i=balls.length-1;i>=0;i--) if(balls[i]._dead) balls.splice(i,1);

    updateCount();
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // Draw node links first
    ctx.strokeStyle='rgba(255,255,255,0.55)'; ctx.lineWidth=2;
    for(const L of links){
      const {a,b,slotA,slotB}=L;
      if(a._dead||b._dead) continue;
      const A=anchor(a,slotA), B=anchor(b,slotB);
      ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke();
    }

    // Balls with squash/stretch + TRIAD internals
    for(const b of balls){
      let sx=1, sy=1;
      if (b.squashT>0){
        const t=b.squashT/10, amt=0.35*Math.sin(t*Math.PI);
        if(b.squashAxis==='x'){ sx=1+amt; sy=1-amt; } else { sy=1+amt; sx=1-amt; }
      }
      ctx.save(); ctx.translate(b.x,b.y); ctx.scale(sx,sy);

      if(b.type===SMALL){
        ctx.fillStyle='#ffffff';
        ctx.beginPath(); ctx.arc(0,0,R_SMALL,0,Math.PI*2); ctx.fill();

      } else if(b.type===SPAWNER){
        ctx.fillStyle='#ffffff';
        ctx.beginPath(); ctx.arc(0,0,R_SPAWNER-2,0,Math.PI*2); ctx.fill();
        ctx.lineWidth=2; ctx.strokeStyle='rgba(255,255,255,0.9)';
        ctx.beginPath(); ctx.arc(0,0,R_SPAWNER,0,Math.PI*2); ctx.stroke();

      } else if(b.type===FACTORY){
        ctx.fillStyle='rgba(255,255,255,0.95)';
        ctx.beginPath(); ctx.arc(0,0,R_FACTORY,0,Math.PI*2); ctx.fill();
        // show available N/S “ports”
        ctx.strokeStyle='rgba(255,255,255,0.35)'; ctx.lineWidth=1;
        if(!b.slots.top){    ctx.beginPath(); ctx.moveTo(0,-R_FACTORY); ctx.lineTo(0,-R_FACTORY-6); ctx.stroke(); }
        if(!b.slots.bottom){ ctx.beginPath(); ctx.moveTo(0,R_FACTORY);  ctx.lineTo(0,R_FACTORY+6); ctx.stroke(); }

      } else if(b.type===TRIAD){
        // big body
        ctx.fillStyle='rgba(255,255,255,0.95)';
        ctx.beginPath(); ctx.arc(0,0,R_TRIAD,0,Math.PI*2); ctx.fill();
        // medium “ring” sitting to the side
        const off=b.middleOffset;
        ctx.fillStyle='#ffffff';
        ctx.beginPath(); ctx.arc(off.x,off.y,R_SPAWNER-3,0,Math.PI*2); ctx.fill();
        ctx.lineWidth=2; ctx.strokeStyle='rgba(255,255,255,0.9)';
        ctx.beginPath(); ctx.arc(off.x,off.y,R_SPAWNER-1,0,Math.PI*2); ctx.stroke();
        // inner small core
        if (b.innerDot){
          ctx.fillStyle='#ffffff';
          ctx.beginPath(); ctx.arc(0,0,R_SMALL,0,Math.PI*2); ctx.fill();
        }
        // N/S port hints
        ctx.strokeStyle='rgba(255,255,255,0.35)'; ctx.lineWidth=1;
        if(!b.slots.top){    ctx.beginPath(); ctx.moveTo(0,-R_TRIAD); ctx.lineTo(0,-R_TRIAD-6); ctx.stroke(); }
        if(!b.slots.bottom){ ctx.beginPath(); ctx.moveTo(0,R_TRIAD);  ctx.lineTo(0,R_TRIAD+6); ctx.stroke(); }

      } else if(b.type===RED){
        ctx.fillStyle='#ff4d4d';
        ctx.beginPath(); ctx.arc(0,0,R_RED,0,Math.PI*2); ctx.fill();
      }

      ctx.restore();
    }
  }

  function loop(){ update(); draw(); requestAnimationFrame(loop); }
  loop();
})();
</script>
</body>
</html>
